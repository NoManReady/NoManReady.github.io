(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{93:function(a,n,t){"use strict";t.r(n);var l=t(0),e=Object(l.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,n=a.$createElement,t=a._self._c||n;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"高性能-lua"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高性能-lua","aria-hidden":"true"}},[a._v("#")]),a._v(" 高性能 lua")]),t("h2",{attrs:{id:"用-local-声明变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用-local-声明变量","aria-hidden":"true"}},[a._v("#")]),a._v(" 用 local 声明变量")]),t("blockquote",[t("p",[a._v("lua5.0 后 lua 采用寄存器式的模式，声明的 locla 变量都会存储在寄存器中")])]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("//声明local时产生的伪指令（a=a+b）：\n//a是寄存器0 b是寄存器1\nADD 0 1\n//若没有声明local即默认global变量产生的伪指令：\nGETGLOBAL    0 0    ;get a\nGETGLOBAL    1 1    ;get b\nADD          0 1    ;do add\nSETGLOBAL    0 1    ;set a\n")])]),t("p",[a._v("所以声明 lua 变量时尽量用 local 声明变量的作用域，下面为测试结果：")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("//每次调用全局的math.sin\na = os.clock()\nfor i = 1,10000000 do\n  local x = math.sin(i)\nend\nb = os.clock()\nprint(b-a)\n\n//每次调用局部的math.sin\na = os.clock()\nlocal sin=math.sin\nfor i = 1,10000000 do\n  local x = sin(i)\nend\nb = os.clock()\nprint(b-a)\n")])]),t("h3",{attrs:{id:"global"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#global","aria-hidden":"true"}},[a._v("#")]),a._v(" global")]),t("p",[t("img",{attrs:{src:"/img/global.png",alt:"global"}})]),t("h3",{attrs:{id:"local"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#local","aria-hidden":"true"}},[a._v("#")]),a._v(" local")]),t("p",[t("img",{attrs:{src:"/img/local.png",alt:"local"}})]),t("h2",{attrs:{id:"预填充-table"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#预填充-table","aria-hidden":"true"}},[a._v("#")]),a._v(" 预填充 table")]),t("p",[a._v("表在 Lua 中使用十分频繁，因为表几乎代替了 Lua 的所有容器。所以快速了解一下 Lua 底层是如何实现表，对我们编写 Lua 代码是有好处的。")]),t("p",[a._v("Lua 的表分为两个部分：数组(array)部分和哈希(hash)部分。数组部分包含所有从 1 到 n 的整数键，其他的所有键都储存在哈希部分中。")]),t("p",[a._v("哈希部分其实就是一个哈希表，哈希表本质是一个数组，它利用哈希算法将键转化为数组下标，若下标有冲突(即同一个下标对应了两个不同的键)，则它会将冲突的下标上创建一个链表，将不同的键串在这个链表上，这种解决冲突的方法叫做：链地址法。")]),t("p",[a._v("当我们把一个新键值赋给表时，若数组和哈希表已经满了，则会触发一个再哈希(rehash)。再哈希的代价是高昂的。首先会在内存中分配一个新的长度的数组，然后将所有记录再全部哈希一遍，将原来的记录转移到新数组中。新哈希表的长度是最接近于所有元素数目的 2 的乘方。")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("//以下代码执行时间为1.53秒：\na = os.clock()\nfor i = 1,2000000 do\n    local a = {}\n    a[1] = 1; a[2] = 2; a[3] = 3\nend\nb = os.clock()\nprint(b-a)  --1.528293\n\n//如果我们在创建表的时候就填充好它的大小，则只需要0.75秒，一倍的效率提升！\na = os.clock()\nfor i = 1,2000000 do\n    local a = {1,1,1}\n    a[1] = 1; a[2] = 2; a[3] = 3\nend\nb = os.clock()\nprint(b-a)  --0.746453\n")])]),t("ul",[t("li",[a._v("所以，当需要创建非常多的小 size 的表时，应预先填充好表的大小。")])]),t("h2",{attrs:{id:"lua-字符串"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lua-字符串","aria-hidden":"true"}},[a._v("#")]),a._v(" lua 字符串")]),t("p",[a._v("第一，所有的字符串在 Lua 中都只储存一份拷贝。当新字符串出现时，Lua 检查是否有其相同的拷贝，若没有则创建它，否则，指向这个拷贝。这可以使得字符串比较和表索引变得相当的快，因为比较字符串只需要检查引用是否一致即可；但是这也降低了创建字符串时的效率，因为 Lua 需要去查找比较一遍。")]),t("p",[a._v("第二，所有的字符串变量，只保存字符串引用，而不保存它的 buffer。这使得字符串的赋值变得十分高效。例如在 Perl 中，$x = $y，会将$y 的 buffer 整个的复制到$x 的 buffer 中，当字符串很长时，这个操作的代价将十分昂贵。而在 Lua，同样的赋值，只复制引用，十分的高效。")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("//在Lua中，以下代码将花费6.65秒：\n\na = os.clock()\nlocal s = ''\nfor i = 1,300000 do\n    s = s .. 'a'\nend\nb = os.clock()\nprint(b-a)  --6.649481\n//我们可以用table来模拟buffer，下面的代码只需花费0.72秒，9倍多的效率提升：\n\na = os.clock()\nlocal s = ''\nlocal t = {}\nfor i = 1,300000 do\n    t[#t + 1] = 'a'\nend\ns = table.concat( t, '')\nb = os.clock()\nprint(b-a)  --0.07178\n")])]),t("ul",[t("li",[a._v("所以：在大字符串连接中，我们应避免…。应用 table 来模拟 buffer，然后 concat 得到最终字符串。")])]),t("p",[t("a",{attrs:{href:"http://wuzhiwei.net/lua_performance/",target:"_blank",rel:"noopener noreferrer"}},[a._v("文章地址")])])])}],!1,null,null,null);n.default=e.exports}}]);