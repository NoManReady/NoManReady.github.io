(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{117:function(e,t,n){"use strict";n.r(t);var r=n(0),a=Object(r.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"js积累"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js积累","aria-hidden":"true"}},[e._v("#")]),e._v(" js积累")]),n("h2",{attrs:{id:"全局匹配"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#全局匹配","aria-hidden":"true"}},[e._v("#")]),e._v(" 全局匹配")]),n("p",[e._v("number:/-?[0-9]*.?[0-9]+(?:e[-+]?\\d+)?/ig")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("var number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n    var numbers = args.match(number)\n    return numbers ? numbers.map(Number) : []\n}\n\n")])]),n("h2",{attrs:{id:"延迟函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#延迟函数","aria-hidden":"true"}},[e._v("#")]),e._v(" 延迟函数")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const defer = typeof Promise=='function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;\n")])]),n("h2",{attrs:{id:"fetch封装"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#fetch封装","aria-hidden":"true"}},[e._v("#")]),e._v(" fetch封装")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/**\n * c_fetch\n * 基于原生fetch封装了拦截器功能，暴露出来的c_fetch跟原生fetch用法一致，只是增加了拦截器功能。拦截器用法参考axios的拦截器用法。\n * 拦截器: c_fetch.interceptors\n * 注意: 拦截器不拦截reject类型的response结果\n */\n\n(function () {\n  //定义用来存储拦截请求和拦截响应结果的处理函数集合\n  let interceptors_req = [], interceptors_res = [];\n\n  function c_fetch (input, init = {}) {\n    //fetch默认请求方式设为GET\n    if(!init.method){\n      init.method = 'GET'\n    }\n    \n    //interceptors_req是拦截请求的拦截处理函数集合\n    interceptors_req.forEach(interceptors => {\n      init = interceptors(init);\n    })\n    \n    //在原生fetch外面封装一个promise，为了在promise里面可以对fetch请求的结果做拦截处理。\n    //同时，保证c_fetch函数返回的结果是个promise对象。\n    return new Promise(function (resolve, reject) {\n      //发起fetch请求，fetch请求的形参是接收上层函数的形参\n      fetch(input, init).then(res => {\n        //interceptors_res是拦截响应结果的拦截处理函数集合\n        interceptors_res.forEach(interceptors => {\n          //拦截器对响应结果做处理，把处理后的结果返回给响应结果。\n          res = interceptors(res);\n        })\n        //将拦截器处理后的响应结果resolve出去\n        resolve(res)\n      }).catch(err => {\n        reject(err);\n      })\n    })\n\n  }\n  \n  //在c_fetch函数上面增加拦截器interceptors，拦截器提供request和response两种拦截器功能。\n  //可以通过request和response的use方法来绑定两种拦截器的处理函数。\n  //use方法接收一个参数，参数为一个callback函数，callback函数用来作为拦截器的处理函数；\n  //request.use方法会把callback放在interceptors_req中，等待执行。\n  //response.use方法会把callback放在interceptors_res中，等待执行。\n  //拦截器的处理函数callback接收一个参数。\n  //request拦截器的callback接收的是请求发起前的config；\n  //response拦截器的callback接收的是网络请求的response结果。\n  c_fetch.interceptors = {\n    request: {\n      use: function (callback) {\n        interceptors_req.push(callback);\n      }\n    },\n    response: {\n      use: function (callback) {\n        interceptors_res.push(callback);\n      }\n    }\n  }\n\n  export default c_fetch;\n})()\n")])]),n("h2",{attrs:{id:"es6实现mixin"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#es6实现mixin","aria-hidden":"true"}},[e._v("#")]),e._v(" ES6实现mixin")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function mix(...mixins) {\n  class Mix { }\n  for (let mixin of mixins) {\n    copyProperties(Mix, mixin); // 拷贝实例属性\n    copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性\n  }\n  return Mix;\n}\nfunction copyProperties(target, source) {\n  for (let key of Reflect.ownKeys(source)) {\n    if (key !== "constructor"\n      && key !== "prototype"\n      && key !== "name"\n    ) {\n      let desc = Object.getOwnPropertyDescriptor(source, key);\n      Object.defineProperty(target, key, desc);\n    }\n  }\n}\n')])]),n("h2",{attrs:{id:"defer-async"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#defer-async","aria-hidden":"true"}},[e._v("#")]),e._v(" defer&async")]),n("p",[n("img",{attrs:{src:"/img/async&defer.png",alt:"脚本加载顺序"}})]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<script src="script.js"><\/script>\n\n没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。\n\n<script async src="script.js"><\/script>\n\n有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。\n\n<script defer src="myscript.js"><\/script>\n\n有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。\n\n不加：堵塞加载脚本并执行\nasync：异步加载脚本。加载完就执行（执行与顺序无关）\ndefer：异步加载脚本。在元素解析完之后DOMContentLoaded之前执行（执行与dom相关的程序）\n')])]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<!DOCTYPE html>\n<html lang="en">\n\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <meta http-equiv="X-UA-Compatible" content="ie=edge">\n  <title>Document</title>\n  <script src="/test1.js" async><\/script>\n  \x3c!-- \n    console.log(\'defer\')\n    console.log(document.getElementById(\'test\'))\n   --\x3e\n  <script src="/test.js" defer><\/script>\n  \x3c!-- \n    console.log(\'async\')\n    console.log(document.getElementById(\'test\'))\n   --\x3e\n</head>\n\n<body>\n  <div class="masked" id="test">托尔斯泰</div>\n  <script>\n    console.log("Before DOM fully loaded and parsed")\n    document.addEventListener("DOMContentLoaded", function (event) {\n      console.log("DOM fully loaded and parsed")\n    });\n  <\/script>\n</body>\n\n</html>\n')])]),n("h2",{attrs:{id:"domcontentloaded与load"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#domcontentloaded与load","aria-hidden":"true"}},[e._v("#")]),e._v(" DOMContentLoaded与load")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("DOMContentLoaded:dom（包括js、css、html）解析完成，无需等待图片等其他资源加载完成；\n\nload:等待图片等其他资源加载完成;\n")])]),n("h2",{attrs:{id:"etag与cache-control（http协议缓存）"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#etag与cache-control（http协议缓存）","aria-hidden":"true"}},[e._v("#")]),e._v(" eTag与Cache-Control（HTTP协议缓存）")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Cache-Control：常见的取值有private、no-cache、max-age、must-revalidate等，默认为private。\n\n说明：\npublic：\t所有内容都将被缓存(客户端和代理服务器都可缓存)\nprivate：\t内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)\nno-cache：\t必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。\nno-store：\t所有内容都不会被缓存到缓存或 Internet 临时文件中\nmust-revalidation/proxy-revalidation：\t如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证\nmax-age=xxx (xxx is numeric)：\t缓存的内容将在 xxx 秒后失效, 这个选项只在HTTP 1.1可用, 并如果和Last-Modified一起使用时, 优先级较高\n")])]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Etag：URL的Entity Tag，用于标示URL对象是否改变。\n\n服务端返回头加入（Etag: xxx_etag)xxx_etag可为请求内容的MD5或hash值\n再次请求时请求头将会带上（If-None-Match: xxx_etag）\n服务端比较xxx_etag，如果完全相等-》服务器就会认为客户端已经有最新的文件内容的缓存了，于是服务器就会发送一个响应码为“304”的http响应（304：不包含任何响应的内容，只是提示客户端缓存的内容是最新的）\n")])]),n("h2",{attrs:{id:"cookie"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cookie","aria-hidden":"true"}},[e._v("#")]),e._v(" Cookie")]),n("p",[n("a",{attrs:{href:"https://www.cnblogs.com/kabi/p/6699242.html",title:"Cookie 详细讲解",target:"_blank",rel:"noopener noreferrer"}},[e._v("Cookie 详细讲解")])]),n("h2",{attrs:{id:"函数式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数式","aria-hidden":"true"}},[e._v("#")]),e._v(" 函数式")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/**\n * compose函数式\n * @param {*} f \n */\nconst compose = (...args) => x => args.reduceRight((value, item) => item(value), x)\n// const f = x => x + 2\n// const g = x => x * 2\n// compose(g, f)(2)\nexport default compose\n\n/**\n * 变量缓存函数式\n * @param {*} f \n */\nconst memorize = f => {\n  let _cache = {}\n  return function () {\n    let _cache_str = JSON.stringify(arguments)\n    _cache[_cache_str] = _cache[_cache_str] || f.apply(f, arguments)\n    return _cache[_cache_str]\n  }\n}\n// const fn=(x,y)=>x+y\n// memFn=memorize(fn)\nexport default memorize\n")])])])}],!1,null,null,null);t.default=a.exports}}]);