(window.webpackJsonp=window.webpackJsonp||[]).push([[277],{371:function(e,a,n){"use strict";n.r(a);var r=n(0),s=Object(r.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,a=e.$createElement,n=e._self._c||a;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"vue-config"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue-config","aria-hidden":"true"}},[e._v("#")]),e._v(" vue config")]),n("h2",{attrs:{id:"缩小文件的搜索范围"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#缩小文件的搜索范围","aria-hidden":"true"}},[e._v("#")]),e._v(" 缩小文件的搜索范围")]),n("h3",{attrs:{id:"优化loader配置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#优化loader配置","aria-hidden":"true"}},[e._v("#")]),e._v(" 优化Loader配置")]),n("p",[e._v("由于Loader对文件的转换操作很耗时，所以需要让尽可能少的文件被Loader处理。我们可以通过以下3方面优化Loader配置:")]),n("ol",[n("li",[e._v("优化正则匹配")]),n("li",[e._v("通过cacheDirectory选项开启缓存")]),n("li",[e._v("通过include、exclude来减少被处理的文件。\n实践如下：项目原配置：")])]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("{\n    // 1、如果项目源码中只有js文件，就不要写成/\\.jsx?$/，以提升正则表达式的性能\n    test: /\\.js$/,\n    // 2、babel-loader支持缓存转换出的结果，通过cacheDirectory选项开启\n    loader: 'babel-loader?cacheDirectory',\n    // 3、只对项目根目录下的src 目录中的文件采用 babel-loader\n    include: [resolve('src')]\n}\n")])]),n("h3",{attrs:{id:"优化resolve-modules配置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#优化resolve-modules配置","aria-hidden":"true"}},[e._v("#")]),e._v(" 优化resolve.modules配置")]),n("p",[e._v("resolve.modules 用于配置Webpack去哪些目录下寻找第三方模块。resolve.modules的默认值是［node modules］，含义是先去当前目录的/node modules目录下去找我们想找的模块，如果没找到，就去上一级目录…/node modules中找，再没有就去…/ … /node modules中找，以此类推，这和Node.js的模块寻找机制很相似。当安装的第三方模块都放在项目根目录的./node modules目录下时，就没有必要按照默认的方式去一层层地寻找，可以指明存放第三方模块的绝对路径，以减少寻找。优化后配置：")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("resolve: {\n  // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤\n  modules: [path.resolve(__dirname,'node_modules')]\n}\n")])]),n("h3",{attrs:{id:"优化resolve-alias配置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#优化resolve-alias配置","aria-hidden":"true"}},[e._v("#")]),e._v(" 优化resolve.alias配置")]),n("p",[e._v("resolve.alias配置项通过别名来将原导入路径映射成一个新的导入路径。如项目中的配置使用：")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("alias: {\n  '@': resolve('src'),\n},\n\n// 通过以上的配置，引用src底下的common.js文件，就可以直接这么写\nimport common from '@/common.js';\n")])]),n("h3",{attrs:{id:"优化resolve-extensions配置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#优化resolve-extensions配置","aria-hidden":"true"}},[e._v("#")]),e._v(" 优化resolve.extensions配置")]),n("p",[e._v("在导入语句没带文件后缀时，Webpack 会在自动带上后缀后去尝试询问文件是否存在。")]),n("p",[e._v("默认是：extensions :[’. js ‘,’. json '] 。也就是说，当遇到require ( '. /data '）这样的导入语句时，Webpack会先去寻找./data .js 文件，如果该文件不存在，就去寻找./data.json 文件，如果还是找不到就报错。如果这个列表越长，或者正确的后缀越往后，就会造成尝试的次数越多，所以 resolve .extensions 的配置也会影响到构建的性能。  \n优化措施：")]),n("ul",[n("li",[e._v("后缀尝试列表要尽可能小，不要将项目中不可能存在的情况写到后缀尝试列表中。")]),n("li",[e._v("频率出现最高的文件后缀要优先放在最前面，以做到尽快退出寻找过程。")]),n("li",[e._v("在源码中写导入语句时，要尽可能带上后缀，从而可以避免寻找过程。\n例如在确定的情况下将 require(’. /data ‘)写成require(’. /data.json ')，可以结合enforceExtension 和 enforceModuleExtension开启使用来强制开发者遵守这条优化")])]),n("h3",{attrs:{id:"优化module-noparse配置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#优化module-noparse配置","aria-hidden":"true"}},[e._v("#")]),e._v(" 优化module.noParse配置")]),n("p",[e._v("noParse配置项可以让Webpack忽略对部分没采用模块化的文件的递归解析和处理，这 样做的好处是能提高构建性能。原因是一些库如jQuery、ChartJS 庞大又没有采用模块化标准，让Webpack去解析这些文件既耗时又没有意义。\nnoParse是可选的配置项，类型需要是RegExp 、[RegExp]、function中的一种。例如，若想要忽略jQuery 、ChartJS ，则优化配置如下：")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 使用正则表达式 \nnoParse: /jquerylchartjs/ \n// 使用函数，从 Webpack3.0.0开始支持 \nnoParse: (content)=> { \n  // 返回true或false \n  return /jquery|chartjs/.test(content); \n}\n")])]),n("p",[e._v("##2、减少冗余代码       \nbabel-plugin-transform-runtime 是Babel官方提供的一个插件，作用是减少冗余的代码 。 Babel在将ES6代码转换成ES5代码时，通常需要一些由ES5编写的辅助函数来完成新语法的实现，例如在转换 class extent 语法时会在转换后的 ES5 代码里注入 extent 辅助函数用于实现继承。babel-plugin-transform-runtime会将相关辅助函数进行替换成导入语句，从而减小babel编译出来的代码的文件大小。")]),n("h2",{attrs:{id:"使用happypack多进程解析和处理文件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用happypack多进程解析和处理文件","aria-hidden":"true"}},[e._v("#")]),e._v(" 使用HappyPack多进程解析和处理文件")]),n("p",[e._v("由于有大量文件需要解析和处理，所以构建是文件读写和计算密集型的操作，特别是当文件数量变多后，Webpack构建慢的问题会显得更为严重。运行在 Node.之上的Webpack是单线程模型的，也就是说Webpack需要一个一个地处理任务，不能同时处理多个任务。Happy Pack ( https://github.com/amireh/happypack ）就能让Webpack做到这一点，它将任务分解给多个子进程去并发执行，子进程处理完后再将结果发送给主进程。\n项目中HappyPack使用配置：")]),n("ol",[n("li",[e._v("HappyPack插件安装：")])]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("$ npm i -D happypack\n")])]),n("ol",{attrs:{start:"2"}},[n("li",[e._v("webpack.base.conf.js 文件对module.rules进行配置")])]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("module: {\n  `rules: [\n    {\n      test: /\\.js$/,\n      // 将对.js 文件的处理转交给 id 为 babel 的HappyPack实例\n        use:['happypack/loader?id=babel'],\n        include: [resolve('src'), resolve('test'),   \n        resolve('node_modules/webpack-dev-server/client')],\n      // 排除第三方插件\n        exclude:path.resolve(__dirname,'node_modules'),\n    },\n    {\n      test: /\\.vue$/,\n      use: ['happypack/loader?id=vue'],\n    },\n  ]`\n}\n")])]),n("ol",{attrs:{start:"3"}},[n("li",[e._v("webpack.prod.conf.js 文件进行配置")])]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const HappyPack = require('happypack');\n// 构造出共享进程池，在进程池中包含5个子进程\nconst HappyPackThreadPool = HappyPack.ThreadPool({size:5});\nplugins: [\n    new HappyPack({\n      // 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件\n      id:'vue',\n      loaders:[\n        {\n          loader:'vue-loader',\n          options: vueLoaderConfig\n        }\n      ],\n      threadPool: HappyPackThreadPool\n    }),\n    new HappyPack({\n      // 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件\n      id:'babel',\n      // 如何处理.js文件，用法和Loader配置中一样\n      loaders:['babel-loader?cacheDirectory'],\n      threadPool: HappyPackThreadPool\n    })\n]\n")])]),n("h2",{attrs:{id:"使用paralleluglifyplugin多进程压缩代码文件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用paralleluglifyplugin多进程压缩代码文件","aria-hidden":"true"}},[e._v("#")]),e._v(" 使用ParallelUglifyPlugin多进程压缩代码文件")]),n("p",[e._v("由于压缩JavaScript 代码时，需要先将代码解析成用 Object 抽象表示的 AST 语法树，再去应用各种规则分析和处理AST ，所以导致这个过程的计算量巨大，耗时非常多。当Webpack有多个JavaScript 文件需要输出和压缩时，原本会使用UglifyJS去一个一个压缩再输出，但是ParallelUglifyPlugin会开启多个子进程，将对多个文件的压缩工作分配给多个子进程去完成，每个子进程其实还是通过UglifyJS去压缩代码，但是变成了并行执行。所以 ParallelUglify Plugin能更快地完成对多个文件的压缩工作。 \n项目中ParallelUglifyPlugin使用配置：")]),n("ol",[n("li",[e._v("ParallelUglifyPlugin插件安装：")])]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  $ npm i -D webpack-parallel-uglify-plugin\n")])]),n("ol",{attrs:{start:"2"}},[n("li",[e._v("webpack.prod.conf.js 文件进行配置")])]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const ParallelUglifyPlugin =require('webpack-parallel-uglify-plugin');\nplugins: [\n  new ParallelUglifyPlugin({\n    cacheDir: '.cache/',\n    uglifyJs:{\n      compress: {\n        warnings: false\n      },\n      sourceMap: true\n    }\n  })\n]\n")])]),n("h2",{attrs:{id:"使用自动刷新"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用自动刷新","aria-hidden":"true"}},[e._v("#")]),e._v(" 使用自动刷新")]),n("p",[e._v("借助自动化的手段，在监听到本地源码文件发生变化时，自动重新构建出可运行的代码后再控制浏览器刷新。Webpack将这些功能都内置了，并且提供了多种方案供我们选择。 \n项目中自动刷新的配置：")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("devServer: {\n  watchOptions: {\n    // 不监听的文件或文件夹，支持正则匹配\n    ignored: /node_modules/,\n    // 监听到变化后等300ms再去执行动作\n    aggregateTimeout: 300,\n    // 默认每秒询问1000次\n    poll: 1000\n  }\n}\n")])]),n("p",[e._v("相关优化措施：")]),n("ol",[n("li",[e._v("配置忽略一些不监听的一些文件，如：node_modules。")]),n("li",[e._v("watchOptions.aggregateTirneout 的值越大性能越好，因为这能降低重新构建的频率。")]),n("li",[e._v("watchOptions.poll 的值越小越好，因为这能降低检查的频率。")])]),n("h2",{attrs:{id:"开启模块热替换"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#开启模块热替换","aria-hidden":"true"}},[e._v("#")]),e._v(" 开启模块热替换")]),n("p",[e._v("DevServer 还支持一种叫做模块热替换（ Hot Module Replacement ）的技术可在不刷新整个网页的情况下做到超灵敏实时预览。原理是在一个源码发生变化时，只需重新编译发生变化的模块，再用新输出的模块替换掉浏览器中对应的老模块 。模块热替换技术在很大程度上提升了开发效率和体验 。 \n项目中模块热替换的配置：")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  devServer: {\n    hot: true,\n  },\n  plugins: [\n    new webpack.HotModuleReplacementPlugin(),\n  // 显示被替换模块的名称\n    new webpack.NamedModulesPlugin(), // HMR shows correct file names\n  ]\n")])]),n("h2",{attrs:{id:"提取公共代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#提取公共代码","aria-hidden":"true"}},[e._v("#")]),e._v(" 提取公共代码")]),n("p",[e._v("如果每个页面的代码都将这些公共的部分包含进去，则会造成以下问题 ：")]),n("ul",[n("li",[e._v("相同的资源被重复加载，浪费用户的流量和服务器的成本。")]),n("li",[e._v("每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。\n如果将多个页面的公共代码抽离成单独的文件，就能优化以上问题 。Webpack内置了专门用于提取多个Chunk中的公共部分的插件CommonsChunkPlugin。 项目中CommonsChunkPlugin的配置：// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。")])]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  new webpack.optimize.CommonsChunkPlugin({\n    name: 'vendor',\n    minChunks: function(module, count) {\n      return (\n        module.resource &&\n        /\\.js$/.test(module.resource) &&\n        module.resource.indexOf(\n          path.join(__dirname, '../node_modules')\n        ) === 0\n      );\n    }\n  }),\n  // 抽取出代码模块的映射关系\n  new webpack.optimize.CommonsChunkPlugin({\n    name: 'manifest',\n    chunks: ['vendor']\n  })\n")])]),n("h2",{attrs:{id:"按需加载代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#按需加载代码","aria-hidden":"true"}},[e._v("#")]),e._v(" 按需加载代码")]),n("p",[e._v("通过vue写的单页应用时，可能会有很多的路由引入。当打包构建的时候，javascript包会变得非常大，影响加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。 \n项目中路由按需加载（懒加载）的配置：")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const Foo = () => import('./Foo.vue')\nconst router = new VueRouter({\n  routes: [\n    { path: '/foo', component: Foo }\n  ]\n})\n")])]),n("h2",{attrs:{id:"优化sourcemap"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#优化sourcemap","aria-hidden":"true"}},[e._v("#")]),e._v(" 优化SourceMap")]),n("p",[e._v("我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩，去掉多余的空格，且babel编译化后，最终会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有bug的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发不好调式，因此sourceMap出现了，它就是为了解决不好调式代码问题的。 SourceMap的可选值如下：\n开发环境推荐：cheap-module-eval-source-map\n生产环境推荐：cheap-module-source-map \n原因如下：")]),n("ol",[n("li",[e._v("源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。因此不管是开发环境或生产环境，我们都希望添加cheap的基本类型来忽略打包前后的列信息。")]),n("li",[e._v("不管是开发环境还是正式环境，我们都希望能定位到bug的源代码具体的位置，比如说某个vue文件报错了，我们希望能定位到具体的vue文件，因此我们也需要module配置。")]),n("li",[e._v("我们需要生成map文件的形式，因此我们需要增加source-map属性。")]),n("li",[e._v("我们介绍了eval打包代码的时候，知道eval打包后的速度非常快，因为它不生成map文件，但是可以对eval组合使用 eval-source-map使用会将map文件以DataURL的形式存在打包后的js文件中。在正式环境中不要使用 eval-source-map, 因为它会增加文件的大小，但是在开发环境中，可以试用下，因为他们打包的速度很快。")])]),n("h2",{attrs:{id:"构建结果输出分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#构建结果输出分析","aria-hidden":"true"}},[e._v("#")]),e._v(" 构建结果输出分析")]),n("p",[e._v("Webpack输出的代码可读性非常差而且文件非常大，让我们非常头疼。为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。这些工具以图形的方式将结果更直观地展示出来，让我们快速了解问题所在。接下来讲解vue项目中用到的分析工具：webpack-bundle-analyzer 。\n项目中在webpack.prod.conf.js进行配置：")]),n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  if (config.build.bundleAnalyzerReport) {\n    var BundleAnalyzerPlugin =   require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n    webpackConfig.plugins.push(new BundleAnalyzerPlugin());\n  }\n  执行 $ npm run build --report\n")])])])}],!1,null,null,null);a.default=s.exports}}]);