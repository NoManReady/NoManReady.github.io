(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{111:function(e,n,t){"use strict";t.r(n);var r=t(0),s=Object(r.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"axios"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#axios","aria-hidden":"true"}},[e._v("#")]),e._v(" Axios")]),t("h2",{attrs:{id:"背景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#背景","aria-hidden":"true"}},[e._v("#")]),e._v(" 背景")]),t("ul",[t("li",[e._v("在项目开发中 ajax 请求是必不可缺少")]),t("li",[e._v("一部分 ajax 请求不需要 loading 或则请求时间少于多少是不显示 loading")]),t("li",[e._v("项目中对请求的同一化处理（错误处理，返回数据格式化处理，loading 处理，token 处理）")]),t("li",[e._v("配置基于个人 vue 项目进行配置，已加载 vux 相关组件，会进行一些依赖的 import（可以按需配置）")])]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import Vue from 'vue'\nimport axios from 'axios'\n//项目的一些环境配置参数，读取host\nimport config from '@/config'\n//vuex状态管理，这里主要进行对全局loading的控制\nimport store from '@/store'\n//vue-router对相应状态码的页面操作（router实例）\nimport router from '@/router'\n//console对应封装\nimport { log } from '@/utils'\n")])]),t("h2",{attrs:{id:"解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决方案","aria-hidden":"true"}},[e._v("#")]),e._v(" 解决方案")]),t("p",[e._v("对于 axios 的封装中我们定义几个参数进行申明")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 加载最小时间\nconst MINI_TIME = 300\n// 超时时间（超时时间）\nlet TIME_OUT_MAX = 5000\n// 环境value\nlet _env = process.env.NODE_ENV\n// 请求接口host\nlet _apiHost = config.api\n// 请求组（判断当前请求数）\nlet _requests = []\n")])]),t("p",[e._v("一般一个项目中的根 host 和 Content-Type 都是统一的，这里对 axios 进行统一的配置（如果这个后端需要 formData 格式的表单即 content-type='application/x-www-form-urlencoded;charset=utf-8’数据，需要对请求数据进行表单序列化，比较快的方式就是引入 qs 库 qs.stringify 进行处理后传输）")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("axios.defaults.headers.common['Content-Type'] = 'application/json'\naxios.defaults.baseURL = _apiHost\n")])]),t("p",[e._v("一般情况下项目中同一时刻都会有不止一个请求在进行（还没有返回），要判断当前是否还存在进行中的 ajax，就需要对requests 这个数组进行维护；")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/**\n * 添加请求，显示loading\n * @param {请求配置} config\n */\nfunction pushRequest(config) {\n  log(`${config.url}--begin`)\n  _requests.push(config)\n  Vue.$vux.loading.show({\n    text: 'Loading'\n  })\n  store.dispatch('loading')\n}\n\n/**\n * 移除请求，无请求时关闭loading\n * @param {请求配置} config\n */\nfunction popRequest(config) {\n  log(`${config.url}--end`)\n  let _index = _requests.findIndex(r => {\n    return r === config\n  })\n  if (_index > -1) {\n    _requests.splice(_index, 1)\n  }\n  if (!_requests.length) {\n    Vue.$vux.loading.hide(0)\n    store.dispatch('loading', false)\n  }\n}\n")])]),t("h2",{attrs:{id:"接下来对-axios-基于上面的准备进行处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接下来对-axios-基于上面的准备进行处理","aria-hidden":"true"}},[e._v("#")]),e._v(" 接下来对 axios 基于上面的准备进行处理")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/**\n * 请求地址，请求数据，是否静默，请求方法\n */\nexport default (url, data = {}, isSilence = false, method = 'POST') => {\n  let _opts = { method, url }\n  //通用数据的合并（token）\n  let _data = Object.assign({}, data, { token: store.getters.token })\n  const _query = {}\n  for (let _key in _data) {\n    if (_data.hasOwnProperty(_key) && _data[_key] !== '') {\n      _query[_key] = _data[_key]\n    }\n  }\n  //axios实例请求定时器ID\n  let _timer = null\n  //判断请求类型\n  if (method.toLocaleUpperCase() === 'POST') {\n    _opts.data = _query\n  } else {\n    _opts.params = _query\n  }\n  //返回一个promise\n  return new Promise((resolve, reject) => {\n    //实例化axios\n    const _instance = axios.create({\n      timeout: TIME_OUT_MAX\n    })\n    //定义请求的唯一标识\n    let _random = { stamp: Date.now(), url: `${_apiHost + url}` }\n    //判断是否静默（静默的话就不加入请求标识队列，不是则申明此请求实例的定时器）\n    if (!isSilence) {\n      _timer = setTimeout(() => {\n        pushRequest(_random)\n      }, MINI_TIME)\n    }\n    //axios实例发送当前请求\n    //请求完成：1、取消当前请求的定时器；2、在当前请求标识队列中移除当前标识；\n    //成功的话返回统一处理后的数据，失败则对状态码进行判断\n    _instance(_opts)\n      .then(res => {\n        let responseData = res.data\n        clearTimeout(_timer)\n        popRequest(_random)\n        resolve(res.data)\n      })\n      .catch(res => {\n        let _response = res.response\n        let _message = null\n        clearTimeout(_timer)\n        popRequest(_random)\n        switch (_response.status) {\n          case 404:\n            _message = '404,错误请求'\n            break\n          case 401:\n            router.push({ path: '/login', query: { redirect: router.currentRoute.fullPath } })\n            _message = '未授权'\n            break\n          case 403:\n            _message = '禁止访问'\n            break\n          case 408:\n            _message = '请求超时'\n            break\n          case 500:\n            _message = '服务器内部错误'\n            break\n          case 501:\n            _message = '功能未实现'\n            break\n          case 503:\n            _message = '服务不可用'\n            break\n          case 504:\n            _message = '网关错误'\n            break\n          default:\n            _message = '未知错误'\n        }\n        if (!isSilence) {\n          Vue.$vux.toast.show({\n            text: _response.data && _response.data.error ? _response.data.error : _message,\n            type: 'warn',\n            width: '10em'\n          })\n        }\n        reject(res)\n      })\n  })\n}\n")])]),t("p",[t("a",{attrs:{href:"https://github.com/NoManReady/Tide/blob/master/src/utils/fetch.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("源文件路径")])]),t("h2",{attrs:{id:"ts封装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ts封装","aria-hidden":"true"}},[e._v("#")]),e._v(" ts封装")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import axios, { AxiosResponse, AxiosRequestConfig, CancelTokenStatic } from 'axios'\nimport { Message, MessageBox } from 'element-ui'\nimport qs from 'qs'\n\nconst SYS_CANCEL = 'System cancel'\nclass Request {\n  protected baseURL: any = process.env.VUE_APP_BASE_URL\n  protected service: any\n  protected pending: Array<{\n    url: string,\n    cancel: Function\n  }> = []\n  protected CancelToken: CancelTokenStatic = axios.CancelToken\n  protected axiosRequestConfig: AxiosRequestConfig = {}\n  protected successCode: Array<number> = [200, 204]\n\n  private static _instance: Request\n\n  private static _token: string\n\n  private constructor() {\n    this.requestConfig()\n    this.service = axios.create(this.axiosRequestConfig)\n    this.interceptorsRequest()\n    this.interceptorsResponse()\n  }\n\n  public static getInstance(): Request {\n    this._instance || (this._instance = new Request())\n    return this._instance\n  }\n  public setToken(token: string): void {\n    Request._token = token\n  }\n  public getToken(): string {\n    return Request._token\n  }\n  public static async resetToken() {\n\n  }\n  protected requestConfig(): void {\n    this.axiosRequestConfig = {\n      // baseURL`将自动加在 `url` 前面，除非 `url` 是一个绝对 URL\n      baseURL: this.baseURL,\n      // `headers` 是即将被发送的自定义请求头\n      headers: {\n        timestamp: new Date().getTime(),\n        'Content-Type': 'application/json'\n      },\n      // transformRequest` 允许在向服务器发送前，修改请求数据\n      transformRequest: [function (data: any) {\n        //对data进行任意转换处理\n        return data;\n      }],\n      // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\n      transformResponse: [function (data: AxiosResponse) {\n        return data\n      }],\n      // `paramsSerializer` 是一个负责 `params` 序列化的函数\n      paramsSerializer: function (params: any) {\n        return qs.stringify(params, { arrayFormat: 'brackets' })\n      },\n      // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)\n      // 如果请求话费了超过 `timeout` 的时间，请求将被中断\n      timeout: 30000,\n      // `withCredentials` 表示跨域请求时是否需要使用凭证\n      withCredentials: false,\n      // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'\n      responseType: 'json',\n      // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称\n      xsrfCookieName: 'XSRF-TOKEN',\n      // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称\n      xsrfHeaderName: 'X-XSRF-TOKEN',\n      // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目\n      maxRedirects: 5,\n      // `maxContentLength` 定义允许的响应内容的最大尺寸\n      maxContentLength: 2000,\n      // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte\n      validateStatus: function (status: number) {\n        return status >= 200 && status < 300\n      },\n      // // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：\n      // // `keepAlive` 默认没有启用\n      // httpAgent: new http.Agent({ keepAlive: true }),\n      // httpsAgent: new https.Agent({ keepAlive: true })\n    }\n  }\n  protected interceptorsRequest(): void {\n    this.service.interceptors.request.use((config: any) => {\n      if (Request._token) {\n        config.headers['authorization'] = Request._token\n        if (config.url.indexOf('?') > -1) {\n          config.url += `&auth=${Request._token}`\n        } else {\n          config.url += `?auth=${Request._token}`\n        }\n      }\n      this.removePending(config)\n      let { cancel, token } = this.CancelToken.source()\n      config.cancelToken = token\n      this.pending.push({ url: `${config.url}/${JSON.stringify(config.data)}&request_type=${config.method}`, cancel })\n      this.requestLog(config)\n      config.$$b_stamp = new Date().getTime()\n      return config\n    }, (error: any) => {\n      return Promise.reject(error)\n    })\n  }\n  protected interceptorsResponse(): void {\n    this.service.interceptors.response.use(\n      (response: any) => {\n        response.config.$$e_stamp = new Date().getTime()\n        this.responseLog(response)\n        this.removePending(response.config)\n        if (this.successCode.indexOf(response.status) === -1) {\n          Message({\n            message: response.data.message || 'Unknow Error',\n            type: 'error',\n            duration: 5 * 1000\n          })\n          if (response.data.code === 401) {\n            MessageBox.confirm(\n              '你已被登出，可以取消继续留在该页面，或者重新登录',\n              '确定登出',\n              {\n                confirmButtonText: '重新登录',\n                cancelButtonText: '取消',\n                type: 'warning'\n              }\n            ).then(() => {\n              Request.resetToken()\n              location.reload()\n            })\n          }\n          return Promise.reject(new Error(response.message || 'Error'))\n        } else {\n          return response.data\n        }\n      },\n      (error: any) => {\n        if (error.isAxiosError) {\n          Message({\n            message: error.message || 'Unknow Error',\n            type: 'error',\n            duration: 5 * 1000\n          })\n        }\n        return Promise.reject(error)\n      }\n    )\n  }\n  protected removePending(config: any): void {\n    for (let index = 0; index < this.pending.length; index++) {\n      let p = this.pending[index]\n      if (p.url === `${config.url}/${JSON.stringify(config.data)}&request_type=${config.method}`) {\n        p.cancel(SYS_CANCEL)\n        this.pending.splice(index, 1)\n      }\n    }\n  }\n  public async post(url: string, data: any = {}, config: object = {}): Promise<any> {\n    try {\n      const result = await this.service.post(url, JSON.stringify(data), config)\n      return result.data\n    } catch (error) {\n      console.error(error)\n    }\n  }\n  public async get(url: string, params: any = {}, config: object = {}): Promise<any> {\n    try {\n      await this.service.get(url, params, config)\n    } catch (error) {\n      console.error(error)\n    }\n  }\n  public async put(url: string, data: any = {}, config: object = {}): Promise<any> {\n    try {\n      await this.service.put(url, qs.stringify(data), config)\n    } catch (error) {\n      console.error(error)\n    }\n  }\n  public async delete(url: string, config: object = {}): Promise<any> {\n    try {\n      await this.service.delete(url, config)\n    } catch (error) {\n      console.error(error)\n    }\n  }\n  protected requestLog(request: any): void { }\n  protected responseLog(response: any): void {\n    if (process.env.NODE_ENV === 'development') {\n      const randomColor = `rgba(${Math.round(Math.random() * 255)},${Math.round(\n        Math.random() * 255\n      )},${Math.round(Math.random() * 255)})`\n      console.log(\n        '%c┍------------------------------------------------------------------┑',\n        `color:${randomColor};`\n      )\n      let time = response.config.$$e_stamp - response.config.$$b_stamp\n      let color = 'currentColor'\n      if (time < 500) {\n        color = 'blue'\n      } else if (time < 1000) {\n        color = 'pink'\n      } else if (time < 1500) {\n        color = 'green'\n      } else {\n        color = 'red'\n      }\n      console.log(`%c| 请求耗时：${time}ms`, `color:${color}`)\n      console.log('| 请求地址：', response.config.url)\n      console.log('| 请求参数：', qs.parse(response.config.data))\n      console.log('| 返回数据：', response.data)\n      console.log(\n        '%c┕------------------------------------------------------------------┙',\n        `color:${randomColor};`\n      )\n    }\n  }\n}\n\nexport default Request.getInstance()\n")])]),t("h2",{attrs:{id:"使用方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用方法","aria-hidden":"true"}},[e._v("#")]),e._v(" 使用方法")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import Request from './utils/request'\nRequest.post('auth', {\n  method: 'login',\n  params: {\n    password: 'U2FsdGVkX19QT/rrXNIAKXXg7dp2AZv6VVRCPUde8UE=',\n    username: 'admin',\n    time: '1575429820',\n    encry: true\n  }\n}).then(d => {\n  Request.setToken(d.sid)\n})\n")])])])}],!1,null,null,null);n.default=s.exports}}]);